{{ $current_container := where $ "ID" .Docker.CurrentContainerID | first }}
{{ $ssl_crt := coalesce $current_container.Env.SSL_CERTIFICATE_PATH "/etc/nginx/certs/default.crt" }}
{{ $ssl_key := coalesce $current_container.Env.SSL_KEY_PATH "/etc/nginx/certs/default.key" }}
{{ $ssl_dhparam := coalesce $current_container.Env.SSL_DHPARAM_PATH "/etc/nginx/certs/default.dhparam.pem" }}
{{ $http_port := coalesce $current_container.Env.HTTP_PORT "80" }}
{{ $https_port := coalesce $current_container.Env.HTTPS_PORT "443" }}

{{ define "location" }}
    {{ $proto := coalesce (.Container.Env.VIRTUAL_PROTO) "http" }}
    location {{ .Subdir }} {
    {{ if .Address }}
        {{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
        {{ if and .Container.Node.ID .Address.HostPort }}
            # {{ .Container.Node.Name }}/{{ .Container.Name }}
            proxy_pass {{ $proto }}://{{ .Container.Node.Address.IP }}:{{ .Address.HostPort }};
        {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
        {{ else if .Network }}
            # {{ .Container.Name }}
            proxy_pass {{ $proto }}://{{ .Network.IP }}:{{ .Address.Port }};
        {{ end }}
    {{ else if .Network }}
        # {{ .Container.Name }}
        proxy_pass {{ $proto }}://{{ .Network.IP }};
    {{ end }}

    {{ if .Container.Env.PROXY_MAX_OBJECT_SIZE }}
        client_max_body_size {{ .Container.Env.PROXY_MAX_OBJECT_SIZE }};
    {{ end }}

    {{ if (and (exists .SslCrt) (exists .SslKey) ( eq $proto "http" )) }}
        proxy_redirect http:// https://;
    {{ end }}

    {{ if (exists (printf "/etc/nginx/htpasswd/%s" .Subdir)) }}
        auth_basic "Restricted";
        auth_basic_user_file {{ (printf "/etc/nginx/htpasswd/%s" .Subdir) }};
    {{ end }}

    {{ if (exists (printf "/etc/nginx/backend.d/%s_location" .Subdir)) }}
        include {{ printf "/etc/nginx/backend.d/%s_location" .Subdir}};
    {{ else if (exists "/etc/nginx/backend.d/default_location") }}
        include /etc/nginx/backend.d/default_location;
    {{ end }}
    }
{{ end }}

# If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
# scheme used to connect to this server
map $http_x_forwarded_proto $proxy_x_forwarded_proto {
  default $http_x_forwarded_proto;
  ''      $scheme;
}

# If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
# Connection header that may have been passed to this server
map $http_upgrade $proxy_connection {
  default upgrade;
  '' close;
}

gzip_types text/plain text/css application/javascript application/json
           application/x-javascript text/xml application/xml application/xml+rss
           text/javascript;

log_format backend '$host $remote_addr - $remote_user [$time_local] '
                   '"$request" $status $body_bytes_sent '
                   '"$http_referer" "$http_user_agent"';

access_log off;

{{ if (exists "/etc/nginx/proxy.conf") }}
include /etc/nginx/proxy.conf;
{{ else }}
# HTTP 1.1 support
proxy_http_version 1.1;
proxy_buffering off;
proxy_set_header Host $http_host;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $proxy_connection;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;
proxy_set_header Proxy "";
{{ end }}

server {
    server_name _; # This is just an invalid value which will never trigger on a real hostname.
    listen {{ $http_port }};
    listen [::]:{{ $http_port }};
    access_log /var/log/nginx/access.log backend;
    return 503;
}
{{ if (and (exists $ssl_crt) (exists $ssl_key)) }}
server {
    server_name _; # This is just an invalid value which will never trigger on a real hostname.
    listen {{ $https_port }} ssl http2;
    listen [::]:{{ $https_port }} ssl http2;
    access_log /var/log/nginx/access.log backend;
    return 503;

    ssl_certificate {{ $ssl_crt }};
    ssl_certificate_key {{ $ssl_key }};
}

server {
    listen {{ $http_port }} default_server;
    listen [::]:{{ $http_port }} default_server;
    access_log /var/log/nginx/access.log backend;
    return 301 https://$host$request_uri;
}

server {
    listen {{ $https_port }} ssl http2 default_server;
    listen [::]:{{ $https_port }} ssl http2 default_server;
    access_log /var/log/nginx/access.log backend;

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
    ssl_prefer_server_ciphers on;

    ssl_session_timeout 5m;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    ssl_certificate {{ $ssl_crt }};
    ssl_certificate_key {{ $ssl_key }};

    {{ if (exists $ssl_dhparam) }}
    ssl_dhparam {{ $ssl_dhparam }};
    {{ end }}

    {{ if coalesce $current_container.Env.NGINX_HSTS_ENABLED true }}
    {{ $age := coalesce $current_container.Env.NGINX_HSTS_MAXAGE "31536000" }}
    add_header Strict-Transport-Security {{ $age }};
    {{ end }}

    {{ range $subdir, $containers := groupBy $ "Env.PROXY_SUBDIR" }}
        {{ $container := first $containers }}

        {{ range $known_network := $current_container.Networks }}
            {{ range $network := $container.Networks }}
                {{ if eq $known_network.Name $network.Name }}
    ## Can be connect with "{{ $network.Name }}" network
                    {{ $port := coalesce $container.Env.VIRTUAL_PORT "80" }}
                    {{ $address := where $container.Addresses "Port" $port | first }}
                    {{ template "location" (dict "Subdir" $subdir "Container" $container "Address" $address "Network" $network "SslKey" $ssl_key "SslCrt" $ssl_crt) }}
                {{ end }}
            {{ end }}
        {{ end }}
    {{ end }}
}

{{ else }}

server {
    listen {{ $http_port }} default_server;
    access_log /var/log/nginx/access.log backend;

    {{ range $subdir, $containers := groupBy $ "Env.PROXY_SUBDIR" }}
        {{ $container := first $containers }}

        {{ range $known_network := $current_container.Networks }}
            {{ range $network := $container.Networks }}
                {{ if eq $known_network.Name $network.Name }}
    ## Can be connect with "{{ $network.Name }}" network
                    {{ $port := coalesce $container.Env.VIRTUAL_PORT "80" }}
                    {{ $address := where $container.Addresses "Port" $port | first }}
                    {{ template "location" (dict "Subdir" $subdir "Container" $container "Address" $address "Network" $network "SslKey" $ssl_key "SslCrt" $ssl_crt) }}
                {{ end }}
            {{ end }}
        {{ end }}
    {{ end }}
}

{{ end }}
